unit uCircle;

interface

uses
   classes,
   sysutils,
   types,
   FMX.Types,
   Fmx.Objects,
   FMX.Controls,
   UiTypes,
   FMX.Graphics;

type

   ITextCircle = interface
      Function GetText : TText;
      Property Text : TText read getText;
   end;

   TTextCircle = class(TCircle,ITextCircle)
   private
     fText : TText;  //this is going be created by the class, rather being injected.
   protected
      function GetText : TText;
      procedure CreateText;
      Procedure DestroyText;
      Procedure SetTextDimensions;
   public
     Constructor Create(aOwner : TComponent); override;
     Destructor Destroy;Override;
   end;

   ITypeWriter = interface;


   TOnWriteLetterProc = reference to Procedure(Sender : ITypeWriter;
                               Const Letter : Char);

   //display text like a type-writer
   ITypeWriter = interface
     Procedure Start;
     Procedure Stop;
     function GetText : String;
     function GetIndex : integer;
     Procedure SetText(const Value : String);
     function getTextSettings : TTextSettings;
     Procedure SetWidth(Const Width : Single);
     function getWidth : Single;
     Procedure SetHeight(Const Height : Single);
     function getHeight : Single;

     Function WriteLetter : Boolean;
     function GetAfterWriteLetter : TOnWriteLetterProc;
     Procedure SetAfterWriteLetter(Const value : TOnWriteLetterProc);
     Procedure SetInterval(Const Count : integer);
     Function  getInterval : Integer;

     Procedure setSentence(Const value : String);
     function getSentence : String;
     Property Interval : Integer read getInterval write setInterval;
     property Sentence : String read getSentence write setSentence;
     Property Text : String read GetText write SetText;
     Property Index : integer read getIndex;
     Property OnAfterWriteLetter : TOnWriteLetterProc read GetAfterWriteLetter write setAfterWriteLetter;
     Property Width : Single read getWidth write setWidth;
     Property Height : Single read getHeight write SetHeight;
   end;


   TTypeWriter = class(TText,ITypeWriter)
   private
     fTimer : TTimer; //loop of when to write letter
     fIndex : integer; //current index of letter
     fCount : integer; //count of letters
     fSentence : String;   //the text;
     fInterval : Integer;
     fOnAfterWriteLetter : TOnWriteLetterProc;
   protected
     Procedure SetTextWidth(Const Text : String);   //I really don't know how to work this out, based on the font...
     function getNext : Boolean;
     function getIndex : integer;
     function GetAfterWriteLetter : TOnWriteLetterProc;
     Procedure SetAfterWriteLetter(Const value : TOnWriteLetterProc);

     Function WriteLetter : Boolean;virtual;
     Procedure SetInterval(Const Count : integer);
     Function getInterval : Integer;

     Procedure setSentence(Const value : String);
     function getSentence : String;

     procedure OnTimer(Sender : TObject); virtual; //loop of timer;
   public
     Procedure Start; virtual;
     Procedure Stop;  virtual;
     constructor create(aOwner : TComponent);override;

   end;

   TTypeWriterDecorator = class(TTypeWriter,ITypeWriter)
   private
     fTyper : ITypeWriter;
   protected
     Function WriteLetter : Boolean; Override;

   public
     constructor create(aOwner : TComponent; const Typer : ITypeWriter); virtual;
   end;

   TCursorTypeWriter = class(TTypeWriterDecorator,ITypeWriter)
   private
      fCursor : TText;

   protected
      Procedure SetCursor(Sender : TObject);
      Function WriteLetter : Boolean; override;
   public
      constructor create(aOwner : TComponent; const Typer : ITypeWriter); Override;
   end;

implementation

  constructor TTypeWriterDecorator.create(aOwner : TComponent; const Typer : ITypeWriter);
  begin
    inherited create(aOwner);
    fTyper := Typer;
  end;

  function TTypeWriterDecorator.WriteLetter : Boolean;
  begin
    result := fTyper.writeLetter;

  end;


  constructor TCursorTypeWriter.create(aOwner : TComponent; const Typer : ITypeWriter);
  begin
    inherited create(aOwner,Typer);
    fTimer := TTimer.create(Self);
    fTimer.Interval := 400;
    FTimer.OnTimer := SetCursor;
    //SetTextWidth(Typer.Text);
    fCursor := TText.create(Self);
   // fCursor.text := '@';
    fCursor.Visible := false;
    fCursor.TextSettings := fTyper.getTextSettings; //copy the text settings
    fCursor.Width := width + 5;
    fCursor.height := height + 5;
    addObject(FCursor);
  end;

  Procedure TCursorTypeWriter.SetCursor(Sender : TObject);
  begin
     if fCursor.text = '|' then FCursor.text := ' '
     else
       fCursor.text := '|';
  end;

  Function TCursorTypeWriter.WriteLetter : boolean;
  begin
    result := inherited WriteLetter;
    //if result then
    begin
      Text := '';
      Text := fTyper.Text + fCursor.Text;
    end
    //else
    //begin

   // end;
  end;


constructor TTypeWriter.create(aOwner : TComponent);
begin
  inherited;
  TextSettings.font.Family :=  'Berlin Sans FB';
  TextSettings.font.size := 30;
  TextSettings.FontColor := TalphaColorRec.Chartreuse;
  TextSettings.HorzAlign := TTextAlign.Leading;
  setinterval(150);
end;

 function TTypeWriter.getIndex : integer;
 begin
   result := fIndex;
 end;

 function TTypeWriter.GetAfterWriteLetter : TOnWriteLetterProc;
 begin
    result := fOnAfterWriteLetter;
 end;

 Procedure TTypeWriter.SetAfterWriteLetter(Const value : TOnWriteLetterProc);
 begin
   fOnAfterWriteLetter := Value;
 end;


 Procedure TTypeWriter.SetTextWidth(Const Text : String); //I really don't know how to work this out, based on the font...
 begin                                    //so for now I'll 'guestimate it
   width := 300; //blunt force...lol
 end;

 procedure TTypeWriter.OnTimer(Sender : TObject); //loop of timer;
 begin
   WriteLetter;
 end;

function TTypeWriter.getNext : boolean;
begin
  result := fIndex < fCount;
  inc(fIndex);
end;

function TTypeWriter.WriteLetter : boolean;
begin
  result := getNext;
  if result then
  begin
    Text := Text + fSentence[fIndex];
    if assigned(fOnAfterWriteLetter) then fOnAfterWriteLetter(Self,fSentence[fIndex]);
  end
  else
  begin
    Stop; //stop timing
  end;
end;

Procedure TTypeWriter.Start;
begin
  Text.Empty;
  fTimer := TTimer.create(self); //loop of when to write letter
  fTimer.Interval := getInterval;
  fTimer.OnTimer := OnTimer; //event of timer
end;

Procedure TTypeWriter.Stop;
begin
  freeandnil(fTimer);
end;

Procedure TTypeWriter.setSentence(Const value : String);
begin
  fSentence := Value;
  fCount := length(fSentence);
  fIndex := -1;
  //SetTextWidth(Value);
end;

function TTypeWriter.getSentence : String;
begin
  result := fSentence;
end;

Procedure TTypeWriter.SetInterval(Const Count : integer);
begin
  fInterval := Count;
end;

Function TTypeWriter.getInterval : Integer;
begin
  result := fInterval;
end;



Procedure TTextCircle.SetTextDimensions;
begin
  fText.Align := TAlignLayout.Center;
  fText.Size.Width := width;
  fText.Size.Height := height;
end;

procedure TTextCircle.CreateText;
begin
  fText := TText.create(Self);
  addObject(FText);
  SetTextDimensions;
  fText.TextSettings.font.Family :=  'Berlin Sans FB';
  fText.TextSettings.font.size := 30;
//  fText.Size.PlatformDefault = False
  fText.Text := 'Some text';
  fText.TextSettings.FontColor := TalphaColorRec.Chartreuse;
end;

Procedure TTextCircle.DestroyText;
begin
  //do I need to remove it.... and destroy
 // fText.Free;
end;


function TTextCircle.GetText : TText;
begin
  result := fText;
end;

 Constructor TTextCircle.Create(aOwner : TComponent);
 begin
    inherited;
    Fill.Color := TAlphaColorRec.Null;
    Size.Width := 250;
    Size.Height := 250;
//  Size.PlatformDefault := False
    Stroke.Color := TAlphaColorRec.White;
    createText;
 end;

 destructor TTextCircle.Destroy;
 begin
   //destroyText;
   inherited;
 end;

end.
